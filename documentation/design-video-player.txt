Adam Atanas

For the video manipulation parts of the project, the code is split depending on whether or not the site is YouTube. YouTube has its own built-in timestamp mechanism (adding an &t=TIME into its URL), so the video manipulator code takes advantage of it.

The video pauser (Get Video Time) works by finding a list of all video tags on the current webpage, then chooses the one that's currently playing (unless we're on YouTube, in which case it chooses the only available video).
It then proceeds to pause that video and obtain its timestamp via the HTML5 API, and pop up a message with a URL to resume playback of that video. The URL will consist of the page URL, plus some extra variables. For YouTube, it adds an &t=TIME, where TIME is the time it obtained previously. Otherwise, it adds two new fields separated by & that denote the time and the source of the video (in case there were multiple videos on the webpage).
The video resumer (Resume Video) then does nothing (for YouTube, which handles its own timestamps), or parses the URL generated by the video pauser (in particular, the two extra variables that video pauser inserted). It then gets the video element on the webpage whose source matches the source variable, and sets its time to the time variable. It finds the correct videos by again searching for all video objects on the webpage.

Note that this means the two programs only work if the video is in the form of an HTML5 video element. This is where CS50 2X comes in, as it can transform a variety of video players (in particular, JWPlayer, which is featured on isites) into FlowPlayer, which uses the HTML5 video tag and is hence accessible to the two functions above. These programs should thus work on most websites in which CS50 2X works, and will likely not work if CS50 2X doesn't.

A major challenge I faced were attempting to hook into the JWPlayer API. After long hours of fumbling around the API, I eventually realized it was not possible due to security practices. This is when I realized we needed CS50 2X in our project, since it can change JWPlayer into FlowPlayer, which my code can successfully integrate with. At first I tried cross-extension calling (i.e. calling CS50 2X from within Harvard Lecture Helper), but CS50 2X did not give me the permissions in its manifest.json file in order to do this. This led to the decision to bundle CS50 2X directly into Harvard Lecture Helper, which has since worked perfectly. A huge thanks to David Malan, who let us bundle the source code for CS50 2X into our extension. Without him, this project would be impossible.